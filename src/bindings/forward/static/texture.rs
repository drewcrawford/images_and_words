//! Forward static textures for GPU rendering.
//!
//! This module provides [`Texture`], a GPU-resident texture type that is immutable after creation.
//! Forward static textures are ideal for assets like sprites, backgrounds, and other image data
//! that doesn't change during rendering.
//!
//! # Features
//!
//! - **GPU-only storage**: Textures reside entirely in GPU memory for optimal performance
//! - **Type-safe pixel formats**: Generic over pixel format types ensuring compile-time safety
//! - **Async creation**: Non-blocking texture upload to avoid stalling the rendering pipeline
//! - **Multiple initialization methods**: From functions, software textures, slices, or asset files
//!
//! # Examples
//!
//! ```no_run
//! # async fn example() -> Result<(), Box<dyn std::error::Error>> {
//! use std::sync::Arc;
//! use images_and_words::bindings::forward::r#static::texture::Texture;
//! use images_and_words::bindings::visible_to::TextureUsage;
//! use images_and_words::pixel_formats::RGBA8UNorm;
//! use images_and_words::Priority;
//!
//! // Get a bound device instance
//! let device: Arc<images_and_words::images::BoundDevice> = todo!();
//!
//! // Create a 256x256 red texture
//! let texture = Texture::<RGBA8UNorm>::new(
//!     &device,
//!     256,
//!     256,
//!     TextureUsage::FragmentShaderSample,
//!     true,  // enable mipmaps
//!     "red_texture",
//!     Priority::UserInitiated,
//!     |_texel| images_and_words::pixel_formats::Unorm4 { r: 255, g: 0, b: 0, a: 255 }  // RGBA red
//! ).await?;
//! # Ok(())
//! # }
//! ```

use std::fmt::{Debug, Display};
use std::path::Path;
use std::sync::Arc;
use crate::bindings::visible_to::TextureUsage;
use crate::images::device::BoundDevice;
use crate::{imp, Priority};
use crate::bindings::software::texture::Texel;
use crate::bindings::software::texture::vtexture::VTexture;
use crate::pixel_formats::sealed::PixelFormat;


/// A GPU-resident, immutable texture.
///
/// `Texture` represents image data that lives entirely in GPU memory and cannot be
/// modified after creation. This makes it ideal for static assets like sprites,
/// UI elements, and backgrounds.
///
/// The texture is generic over its pixel format (e.g., `RGBA8UNorm`, `R32Float`),
/// ensuring type safety when binding to shaders.
///
/// # Memory Management
///
/// Textures are reference-counted via the internal implementation. Cloning a texture
/// is cheap as it only increments the reference count.
///
/// # Thread Safety
///
/// Textures can be safely shared between threads and are `Send + Sync`.
#[derive(Debug,Clone)]
pub struct Texture<Format> {
    pub(crate) imp: imp::GPUableTexture<Format>,
    width: u16,
    height: u16,
}
/// Error type for texture creation operations.
///
/// This error wraps backend-specific errors that can occur during texture creation,
/// such as out-of-memory conditions, invalid parameters, or device errors.
#[derive(Debug,thiserror::Error)]
pub struct Error(
    #[from] imp::Error
);

impl Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "Error: {:?}", self.0)
    }
}
impl<Format: PixelFormat> Texture<Format> {
    /// Creates a new texture with pixel data generated by a function.
    ///
    /// This is the most flexible way to create a texture, allowing you to compute
    /// pixel values on-the-fly based on their coordinates.
    ///
    /// # Arguments
    ///
    /// * `device` - The bound GPU device to create the texture on
    /// * `width` - Width of the texture in pixels (max 65535)
    /// * `height` - Height of the texture in pixels (max 65535)
    /// * `visible_to` - Specifies which shader stages can access this texture
    /// * `mipmaps` - Whether to generate mipmaps for this texture
    /// * `debug_name` - A name for debugging and profiling tools
    /// * `priority` - Task priority for the async upload operation
    /// * `initialize_to` - Function that computes the pixel value for each texel
    ///
    /// # Examples
    ///
    /// ```no_run
    /// # async fn example() -> Result<(), Box<dyn std::error::Error>> {
    /// use std::sync::Arc;
    /// use images_and_words::bindings::forward::r#static::texture::Texture;
    /// use images_and_words::bindings::visible_to::TextureUsage;
    /// use images_and_words::pixel_formats::RGBA8UNorm;
    /// use images_and_words::Priority;
    ///
    /// // Get a bound device instance
    /// let device: Arc<images_and_words::images::BoundDevice> = todo!();
    ///
    /// // Create a gradient texture
    /// let texture = Texture::<RGBA8UNorm>::new(
    ///     &device,
    ///     256,
    ///     256,
    ///     TextureUsage::FragmentShaderSample,
    ///     false,
    ///     "gradient",
    ///     Priority::UserInitiated,
    ///     |texel| {
    ///         let r = (texel.x * 255 / 256) as u8;
    ///         let g = (texel.y * 255 / 256) as u8;
    ///         images_and_words::pixel_formats::Unorm4 { r, g, b: 0, a: 255 }
    ///     }
    /// ).await?;
    /// # Ok(())
    /// # }
    /// ```
    pub async fn new<Initializer: Fn(Texel) -> Format::CPixel>(device: &Arc<BoundDevice>, width: u16, height: u16, visible_to: TextureUsage, mipmaps: bool, debug_name: &str, priority: Priority, initialize_to: Initializer) -> Result<Self,Error>  {
        let imp = imp::GPUableTexture::new_initialize(device, width, height, visible_to, mipmaps, debug_name, priority, initialize_to).await?;
        Ok(Self {
            imp,
            width,
            height
        })
    }
    /// Creates a texture by copying data from a software texture.
    ///
    /// This method uploads an existing CPU-side texture to the GPU. The software
    /// texture's data is copied during creation, so the original can be dropped
    /// afterward.
    ///
    /// # Arguments
    ///
    /// * `device` - The bound GPU device to create the texture on
    /// * `texture` - The software texture to copy from
    /// * `visible_to` - Specifies which shader stages can access this texture
    /// * `debug_name` - A name for debugging and profiling tools
    /// * `priority` - Task priority for the async upload operation
    ///
    /// # Note
    ///
    /// Mipmaps are not generated when creating from software textures. If you need
    /// mipmaps, create the texture with [`new`](Self::new) instead.
    ///
    /// # Examples
    ///
    /// ```no_run
    /// # async fn example() -> Result<(), Box<dyn std::error::Error>> {
    /// use std::sync::Arc;
    /// use images_and_words::bindings::forward::r#static::texture::Texture;
    /// use images_and_words::bindings::software::texture::Texture as SoftwareTexture;
    /// use images_and_words::bindings::visible_to::TextureUsage;
    /// use images_and_words::pixel_formats::RGBA8UNorm;
    /// use images_and_words::Priority;
    ///
    /// // Get a bound device instance
    /// let device: Arc<images_and_words::images::BoundDevice> = todo!();
    ///
    /// // Assume we have a software texture
    /// let soft_texture: SoftwareTexture<RGBA8UNorm> = todo!();
    ///
    /// // Upload it to the GPU
    /// let gpu_texture = Texture::from_software(
    ///     &device,
    ///     &soft_texture,
    ///     TextureUsage::FragmentShaderSample,
    ///     "sprite",
    ///     Priority::UserInitiated
    /// ).await?;
    /// # Ok(())
    /// # }
    /// ```
    pub async fn from_software(device: &Arc<BoundDevice>, texture: &crate::bindings::software::texture::Texture<Format>, visible_to: TextureUsage, debug_name: &str, priority: Priority) -> Result<Self,Error> {
        Self::new(device, texture.width(), texture.height(), visible_to, false, debug_name, priority, |texel| {
            texture.read(texel)
        }).await
    }
    /// Creates a texture from an asset file.
    ///
    /// Loads an image file from disk and creates a GPU texture from it.
    ///
    /// # Arguments
    ///
    /// * `path` - Path to the image file
    /// * `bound_device` - The bound GPU device to create the texture on
    /// * `visible_to` - Specifies which shader stages can access this texture
    /// * `mipmaps` - Whether to generate mipmaps for this texture
    /// * `debug_name` - A name for debugging and profiling tools
    /// * `priority` - Task priority for the async load and upload operation
    ///
    /// # Panics
    ///
    /// Currently unimplemented (will panic with `todo!()`)
    ///
    /// # Future
    ///
    /// This method will support common image formats like PNG, JPEG, etc.
    pub async fn new_asset(_path: &Path, _bound_device: &Arc<BoundDevice>, _visible_to: TextureUsage, _mipmaps: bool,_debug_name: &str, _priority: Priority) -> Result<Self,Error> {
        todo!()
    }
    /// Creates a texture from a slice of pixel data.
    ///
    /// The slice is interpreted as row-major pixel data. The height is automatically
    /// calculated from the slice length and specified width.
    ///
    /// # Arguments
    ///
    /// * `slice` - Raw pixel data in row-major order
    /// * `width` - Width of the texture in pixels
    /// * `bound_device` - The bound GPU device to create the texture on
    /// * `visible_to` - Specifies which shader stages can access this texture
    /// * `mipmaps` - Whether to generate mipmaps for this texture
    /// * `debug_name` - A name for debugging and profiling tools
    /// * `priority` - Task priority for the async upload operation
    ///
    /// # Panics
    ///
    /// Panics if the slice length is not evenly divisible by the width, or if the
    /// calculated height exceeds 65535.
    ///
    /// # Examples
    ///
    /// ```no_run
    /// # async fn example() -> Result<(), Box<dyn std::error::Error>> {
    /// use std::sync::Arc;
    /// use images_and_words::bindings::forward::r#static::texture::Texture;
    /// use images_and_words::bindings::visible_to::TextureUsage;
    /// use images_and_words::pixel_formats::RGBA8UNorm;
    /// use images_and_words::Priority;
    ///
    /// // Get a bound device instance
    /// let device: Arc<images_and_words::images::BoundDevice> = todo!();
    ///
    /// // Create a 2x2 texture with red, green, blue, and white pixels
    /// let pixels = [
    ///     images_and_words::pixel_formats::Unorm4 { r: 255, g: 0, b: 0, a: 255 },    // Red
    ///     images_and_words::pixel_formats::Unorm4 { r: 0, g: 255, b: 0, a: 255 },    // Green
    ///     images_and_words::pixel_formats::Unorm4 { r: 0, g: 0, b: 255, a: 255 },    // Blue
    ///     images_and_words::pixel_formats::Unorm4 { r: 255, g: 255, b: 255, a: 255 } // White
    /// ];
    ///
    /// let texture = Texture::<RGBA8UNorm>::new_slice(
    ///     &pixels,
    ///     2, // width
    ///     &device,
    ///     TextureUsage::FragmentShaderSample,
    ///     false,
    ///     "color_grid",
    ///     Priority::UserInitiated
    /// ).await?;
    /// # Ok(())
    /// # }
    /// ```
    pub async fn new_slice(slice: &[Format::CPixel], width: u16, bound_device: &Arc<BoundDevice>, visible_to: TextureUsage, mipmaps: bool, debug_name: &str, priority: Priority) -> Result<Self,Error> {
        let height = slice.len() / width as usize;
        let height_u16 = height.try_into().unwrap();
        Self::new(bound_device, width, height_u16, visible_to, mipmaps, debug_name, priority, |texel| {
            slice[texel.y as usize * width as usize + texel.x as usize].clone()
        }).await
    }

    /// Returns the width of the texture in pixels.
    pub fn width(&self) -> u16 {
        self.width
    }

    /// Returns the height of the texture in pixels.
    pub fn height(&self) -> u16 {
        self.height
    }
}



