// SPDX-License-Identifier: Parity-7.0.0 OR PolyForm-Noncommercial-1.0.0
//! Forward static textures for GPU rendering.
//!
//! This module provides [`Texture`], a GPU-resident texture type that is immutable after creation.
//! Forward static textures are ideal for assets like sprites, backgrounds, and other image data
//! that doesn't change during rendering.
//!
//! # Features
//!
//! - **GPU-only storage**: Textures reside entirely in GPU memory for optimal performance
//! - **Type-safe pixel formats**: Generic over pixel format types ensuring compile-time safety
//! - **Async creation**: Non-blocking texture upload to avoid stalling the rendering pipeline
//! - **Multiple initialization methods**: From functions, software textures, slices, or asset files
//!
//! # Examples
//!
//! ```
//! # if cfg!(not(feature="backend_wgpu")) { return; }
//! # #[cfg(feature = "testing")]
//! # {
//! # use images_and_words::bindings::forward::r#static::texture::Texture;
//! use images_and_words::bindings::visible_to::{TextureUsage, TextureConfig, CPUStrategy};
//! use images_and_words::images::projection::WorldCoord;
//! use images_and_words::images::view::View;
//! use images_and_words::pixel_formats::RGBA8UNorm;
//! use images_and_words::Priority;
//! # test_executors::spawn_local(async {
//! # let view = View::for_testing();
//! # let engine = images_and_words::images::Engine::rendering_to(view, images_and_words::images::projection::WorldCoord::new(0.0, 0.0, 0.0)).await.expect("can't get engine");
//! # let device = engine.bound_device();
//!
//! // Create a 256x256 red texture
//! let config = TextureConfig {
//!     width: 256,
//!     height: 256,
//!     visible_to: TextureUsage::FragmentShaderSample,
//!     debug_name: "red_texture",
//!     priority: Priority::UserInitiated,
//!     cpu_strategy: CPUStrategy::WontRead,
//!     mipmaps: true,  // Enable mipmaps for static textures
//! };
//!
//! let texture = Texture::<RGBA8UNorm>::new(
//!     &device,
//!     config,
//!     |_texel| images_and_words::pixel_formats::Unorm4 { r: 255, g: 0, b: 0, a: 255 }  // RGBA red
//! ).await.expect("Failed to create texture");
//! # }, "static_texture_creation_doctest");
//! # }
//! ```
//!
//! # See Also
//!
//! - [`forward::dynamic::FrameTexture`](crate::bindings::forward::dynamic::frame_texture::FrameTexture) - For textures that need frequent updates
//! - [`forward::static::Buffer`](crate::bindings::forward::static::buffer::Buffer) - For immutable structured data
//! - [`bindings`](crate::bindings) module documentation - For understanding the full type organization

use crate::bindings::software::texture::Texel;
use crate::bindings::software::texture::vtexture::VTexture;
use crate::bindings::visible_to::{TextureConfig, TextureUsage};
use crate::images::device::BoundDevice;
use crate::pixel_formats::sealed::PixelFormat;
use crate::{Priority, imp};
use std::fmt::{Debug, Display};
use std::path::Path;
use std::sync::Arc;

/// A GPU-resident, immutable texture.
///
/// `Texture` represents image data that lives entirely in GPU memory and cannot be
/// modified after creation. This makes it ideal for static assets like sprites,
/// UI elements, and backgrounds.
///
/// The texture is generic over its pixel format (e.g., `RGBA8UNorm`, `R32Float`),
/// ensuring type safety when binding to shaders.
///
/// # Memory Management
///
/// Textures are reference-counted via the internal implementation. Cloning a texture
/// is cheap as it only increments the reference count.
///
/// # Thread Safety
///
/// Textures can be safely shared between threads and are `Send + Sync`.
#[derive(Debug, Clone)]
pub struct Texture<Format> {
    pub(crate) imp: imp::GPUableTexture2Static<Format>,
    width: u16,
    height: u16,
}
/// Error type for texture creation operations.
///
/// This error wraps backend-specific errors that can occur during texture creation,
/// such as out-of-memory conditions, invalid parameters, or device errors.
#[derive(Debug, thiserror::Error)]
pub struct Error(#[from] imp::Error);

impl Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "Error: {:?}", self.0)
    }
}
impl<Format: PixelFormat> Texture<Format> {
    /// Creates a new texture with pixel data generated by a function.
    ///
    /// This is the most flexible way to create a texture, allowing you to compute
    /// pixel values on-the-fly based on their coordinates.
    ///
    /// # Arguments
    ///
    /// * `device` - The bound GPU device to create the texture on
    /// * `config` - Texture configuration parameters (dimensions, usage, priority, etc.)
    /// * `initialize_to` - Function that computes the pixel value for each texel
    ///
    /// # Examples
    ///
    /// ```
    /// # if cfg!(not(feature="backend_wgpu")) { return; }
    /// # #[cfg(feature = "testing")]
    /// # {
    /// # use images_and_words::bindings::forward::r#static::texture::Texture;
    /// use images_and_words::bindings::visible_to::{TextureUsage, TextureConfig, CPUStrategy};
    /// use images_and_words::images::projection::WorldCoord;
    /// use images_and_words::images::view::View;
    /// use images_and_words::pixel_formats::RGBA8UNorm;
    /// use images_and_words::Priority;
    /// # test_executors::spawn_local(async {
    /// # let view = View::for_testing();
    /// # let engine = images_and_words::images::Engine::rendering_to(view, images_and_words::images::projection::WorldCoord::new(0.0, 0.0, 0.0)).await.expect("can't get engine");
    /// # let device = engine.bound_device();
    ///
    /// // Create a gradient texture
    /// let config = TextureConfig {
    ///     width: 256,
    ///     height: 256,
    ///     visible_to: TextureUsage::FragmentShaderSample,
    ///     debug_name: "gradient",
    ///     priority: Priority::UserInitiated,
    ///     cpu_strategy: CPUStrategy::WontRead,  // Static textures don't need CPU access
    ///     mipmaps: false,
    /// };
    ///
    /// let texture = Texture::<RGBA8UNorm>::new(
    ///     &device,
    ///     config,
    ///     |texel| {
    ///         let r = (texel.x * 255 / 256) as u8;
    ///         let g = (texel.y * 255 / 256) as u8;
    ///         images_and_words::pixel_formats::Unorm4 { r, g, b: 0, a: 255 }
    ///     }
    /// ).await.expect("Failed to create texture");
    /// # }, "static_texture_gradient_doctest");
    /// # }
    /// ```
    pub async fn new<Initializer: Fn(Texel) -> Format::CPixel>(
        device: &Arc<BoundDevice>,
        config: TextureConfig<'_>,
        initialize_to: Initializer,
    ) -> Result<Self, Error> {
        let imp = imp::GPUableTexture2Static::new_with_data(device, config, initialize_to).await?;
        Ok(Self {
            imp,
            width: config.width,
            height: config.height,
        })
    }
    /// Creates a texture by copying data from a software texture.
    ///
    /// This method uploads an existing CPU-side texture to the GPU. The software
    /// texture's data is copied during creation, so the original can be dropped
    /// afterward.
    ///
    /// # Arguments
    ///
    /// * `device` - The bound GPU device to create the texture on
    /// * `texture` - The software texture to copy from
    /// * `visible_to` - Specifies which shader stages can access this texture
    /// * `debug_name` - A name for debugging and profiling tools
    /// * `priority` - Task priority for the async upload operation
    ///
    /// # Note
    ///
    /// Mipmaps are not generated when creating from software textures. If you need
    /// mipmaps, create the texture with [`new`](Self::new) instead.
    ///
    /// # Examples
    ///
    /// ```
    /// # if cfg!(not(feature="backend_wgpu")) { return; }
    /// # #[cfg(feature = "testing")]
    /// # {
    /// # use images_and_words::bindings::forward::r#static::texture::Texture;
    /// use images_and_words::bindings::software::texture::Texture as SoftwareTexture;
    /// use images_and_words::bindings::visible_to::{TextureUsage, TextureConfig, CPUStrategy};
    /// use images_and_words::images::projection::WorldCoord;
    /// use images_and_words::images::view::View;
    /// use images_and_words::pixel_formats::RGBA8UNorm;
    /// use images_and_words::Priority;
    /// # test_executors::spawn_local(async {
    /// # let view = View::for_testing();
    /// # let engine = images_and_words::images::Engine::rendering_to(view, images_and_words::images::projection::WorldCoord::new(0.0, 0.0, 0.0)).await.expect("can't get engine");
    /// # let device = engine.bound_device();
    ///
    /// // Create a software texture first
    /// let soft_texture = SoftwareTexture::<RGBA8UNorm>::new_with(64, 64, |_texel| {
    ///     images_and_words::pixel_formats::Unorm4 { r: 0, g: 255, b: 0, a: 255 } // Green
    /// });
    ///
    /// // Upload it to the GPU
    /// let config = TextureConfig {
    ///     width: soft_texture.width(),
    ///     height: soft_texture.height(),
    ///     visible_to: TextureUsage::FragmentShaderSample,
    ///     debug_name: "sprite",
    ///     priority: Priority::UserInitiated,
    ///     cpu_strategy: CPUStrategy::WontRead,
    ///     mipmaps: false,
    /// };
    /// let gpu_texture = Texture::from_software(
    ///     &device,
    ///     &soft_texture,
    ///     config
    /// ).await.expect("Failed to create GPU texture");
    /// # }, "static_texture_from_software_doctest");
    /// # }
    /// ```
    pub async fn from_software(
        device: &Arc<BoundDevice>,
        texture: &crate::bindings::software::texture::Texture<Format>,
        config: TextureConfig<'_>,
    ) -> Result<Self, Error> {
        Self::new(device, config, |texel| texture.read(texel)).await
    }
    /// Creates a texture from an asset file.
    ///
    /// Loads an image file from disk and creates a GPU texture from it.
    ///
    /// # Arguments
    ///
    /// * `path` - Path to the image file
    /// * `bound_device` - The bound GPU device to create the texture on
    /// * `visible_to` - Specifies which shader stages can access this texture
    /// * `mipmaps` - Whether to generate mipmaps for this texture
    /// * `debug_name` - A name for debugging and profiling tools
    /// * `priority` - Task priority for the async load and upload operation
    ///
    /// # Panics
    ///
    /// Currently unimplemented (will panic with `todo!()`)
    ///
    /// # Future
    ///
    /// This method will support common image formats like PNG, JPEG, etc.
    pub async fn new_asset(
        _path: &Path,
        _bound_device: &Arc<BoundDevice>,
        _visible_to: TextureUsage,
        _mipmaps: bool,
        _debug_name: &str,
        _priority: Priority,
    ) -> Result<Self, Error> {
        todo!()
    }
    /// Creates a texture from a slice of pixel data.
    ///
    /// The slice is interpreted as row-major pixel data. The height is automatically
    /// calculated from the slice length and specified width.
    ///
    /// # Arguments
    ///
    /// * `slice` - Raw pixel data in row-major order
    /// * `width` - Width of the texture in pixels
    /// * `bound_device` - The bound GPU device to create the texture on
    /// * `visible_to` - Specifies which shader stages can access this texture
    /// * `mipmaps` - Whether to generate mipmaps for this texture
    /// * `debug_name` - A name for debugging and profiling tools
    /// * `priority` - Task priority for the async upload operation
    ///
    /// # Panics
    ///
    /// Panics if the slice length is not evenly divisible by the width, or if the
    /// calculated height exceeds 65535.
    ///
    /// # Examples
    ///
    /// ```
    /// # if cfg!(not(feature="backend_wgpu")) { return; }
    /// # #[cfg(feature = "testing")]
    /// # {
    /// # use images_and_words::bindings::forward::r#static::texture::Texture;
    /// use images_and_words::bindings::visible_to::{TextureUsage, TextureConfig, CPUStrategy};
    /// use images_and_words::images::projection::WorldCoord;
    /// use images_and_words::images::view::View;
    /// use images_and_words::pixel_formats::RGBA8UNorm;
    /// use images_and_words::Priority;
    /// # test_executors::spawn_local(async {
    /// # let view = View::for_testing();
    /// # let engine = images_and_words::images::Engine::rendering_to(view, images_and_words::images::projection::WorldCoord::new(0.0, 0.0, 0.0)).await.expect("can't get engine");
    /// # let device = engine.bound_device();
    ///
    /// // Create a 2x2 texture with red, green, blue, and white pixels
    /// let pixels = [
    ///     images_and_words::pixel_formats::Unorm4 { r: 255, g: 0, b: 0, a: 255 },    // Red
    ///     images_and_words::pixel_formats::Unorm4 { r: 0, g: 255, b: 0, a: 255 },    // Green
    ///     images_and_words::pixel_formats::Unorm4 { r: 0, g: 0, b: 255, a: 255 },    // Blue
    ///     images_and_words::pixel_formats::Unorm4 { r: 255, g: 255, b: 255, a: 255 } // White
    /// ];
    ///
    /// let config = TextureConfig {
    ///     width: 2, // will be overridden by new_slice
    ///     height: 2, // will be calculated from slice length
    ///     visible_to: TextureUsage::FragmentShaderSample,
    ///     debug_name: "color_grid",
    ///     priority: Priority::UserInitiated,
    ///     cpu_strategy: CPUStrategy::WontRead,
    ///     mipmaps: false,
    /// };
    /// let texture = Texture::<RGBA8UNorm>::new_slice(
    ///     &pixels,
    ///     &device,
    ///     config
    /// ).await.expect("Failed to create texture");
    /// # }, "static_texture_from_slice_doctest");
    /// # }
    /// ```
    pub async fn new_slice(
        slice: &[Format::CPixel],
        bound_device: &Arc<BoundDevice>,
        config: TextureConfig<'_>,
    ) -> Result<Self, Error> {
        let height = slice.len() / config.width as usize;
        let width = config.width;
        let height_u16 = height.try_into().unwrap();
        assert_eq!(
            slice.len(),
            (width as usize) * height,
            "Slice length must match width * height"
        );
        let actual_config = TextureConfig {
            width,
            height: height_u16,
            visible_to: config.visible_to,
            debug_name: config.debug_name,
            priority: config.priority,
            cpu_strategy: config.cpu_strategy,
            mipmaps: config.mipmaps,
        };
        Self::new(bound_device, actual_config, |texel| {
            slice[texel.y as usize * width as usize + texel.x as usize].clone()
        })
        .await
    }

    /// Returns the width of the texture in pixels.
    pub fn width(&self) -> u16 {
        self.width
    }

    /// Returns the height of the texture in pixels.
    pub fn height(&self) -> u16 {
        self.height
    }
}

// Boilerplate

// Two textures are equal if they refer to the same underlying GPU resource and have the same dimensions.
// Since static textures contain immutable data, Eq is appropriate (no floating-point values).
// Note: We compare dimensions in addition to the GPU resource to ensure complete equality.
impl<Format> PartialEq for Texture<Format> {
    fn eq(&self, other: &Self) -> bool {
        // Compare dimensions first (cheap comparison)
        self.width == other.width && self.height == other.height
            // Then compare the underlying GPU texture identity
            && self.imp == other.imp
    }
}

impl<Format> Eq for Texture<Format> {}

// Hash implementation follows from Eq - allows Texture to be used as HashMap/HashSet keys
impl<Format> std::hash::Hash for Texture<Format> {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        self.imp.hash(state);
        self.width.hash(state);
        self.height.hash(state);
    }
}
